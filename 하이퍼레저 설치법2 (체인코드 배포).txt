https://velog.io/@rivernine/Hyperledger-Fabric-v2.2-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%B6%95%ED%95%98%EA%B8%B0

우분투 방식

==기초 세팅==

1. Docker Desktop 실행 확인: Windows 작업 표시줄 트레이에서 Docker Desktop 아이콘을 확인하여 실행 중인지 확인합니다. 실행 중이 아니라면 실행합니다.

2. Docker Desktop 설정 열기:
작업 표시줄 트레이의 Docker Desktop 아이콘에 마우스 오른쪽 버튼을 클릭합니다.
메뉴에서 “Settings” (설정)을 선택합니다.

3. WSL 통합(Integration) 설정으로 이동:
Docker Desktop 설정 창의 왼쪽 메뉴에서 “Resources” (리소스)를 선택합니다.
하위 메뉴에서 “WSL Integration” (WSL 통합)을 선택합니다.

4. WSL 배포판 활성화:
“Enable integration with my default WSL distro” (기본 WSL 배포판과 통합 활성화) 옵션이 켜져 있는지 확인합니다. (일반적으로 켜져 있습니다.)
그 아래에 설치된 WSL 배포판 목록이 나옵니다 (예: “Ubuntu”). 활성화하고 싶은 배포판(지금 사용 중이신 Ubuntu)의 토글 스위치를 켭니다(On). 이 스위치가 꺼져 있다면 WSL 환경에서 Docker 명령어를 사용할 수 없습니다.

5. “Apply & Restart” (적용 및 다시 시작) 클릭:
변경 사항을 적용하기 위해 설정 창 하단의 “Apply & Restart” 버튼을 클릭합니다. Docker Desktop이 재시작될 것입니다.

docker --version
docker ps

==패브릭 도커 이미지 설치==

curl -sSL https://bit.ly/2ysbOFE | bash -s

==오류 발생시1==

/usr/bin/env: 'bash\r': No such file or directory
/usr/bin/env: use -[v]S to pass options in shebang lines

--해결 방법--
sudo apt update
sudo apt install dos2unix
dos2unix network.sh
dos2unix scripts/*.sh

git config --global core.autocrlf

==오류 발생시2==

./network.config: line X: $'\r': command not found 오류들:
Docker Compose version is obsolete 경고:

--해결 방법--
dos2unix network.config

==오류 발생시3==
CA 컨테이너 미실행 및 관련 인증서 부재:
jq: command not found 오류:
“cannot connect to Docker endpoint” 오류 재발 (잠재적):

--해결 방법--
sudo apt update
sudo apt install jq -y

# test-network 디렉토리에서
find . -type f -name "*.sh" -exec dos2unix {} \;
find . -type f -name "*.config" -exec dos2unix {} \; # .config 파일도 있다면

cd ~/fabric-samples/test-network  # 작업 디렉토리 확인
./network.sh down

# (선택 사항, 더 확실한 정리를 위해)
# docker system prune -af --volumes

./network.sh up createChannel -c mychannel -ca

==다음 단계 확인사항==

sudo apt update
sudo apt install jq -y

==오류 발생시4==

./scripts/packageCC.sh: line 44: go: command not found:
Error: failed to normalize chaincode path: failed to determine module root: exec: "go": executable file not found in $PATH:
Error: failed to read chaincode package at 'basic.tar.gz': open basic.tar.gz: no such file or directory:

--해결 방법--

# 최신 Go 버전 다운로드 (공식 웹사이트에서 최신 버전 확인 후 URL 변경 가능)
# 예시: Go 1.21.x 버전 설치
# (fabric-samples와 호환되는 버전을 사용하는 것이 좋습니다. 이전 go.mod가 go 1.21을 사용했다면 해당 버전을 설치)
wget https://golang.org/dl/go1.21.10.linux-amd64.tar.gz # 원하는 버전의 Linux용 tar.gz 파일 URL

# 이전 Go 설치가 있다면 삭제 (선택 사항, 충돌 방지)
sudo rm -rf /usr/local/go

# 다운로드한 파일 압축 해제 및 /usr/local로 이동
sudo tar -C /usr/local -xzf go1.21.10.linux-amd64.tar.gz

# PATH 환경 변수 설정 (영구 적용을 위해 .bashrc 또는 .profile에 추가)
echo 'export PATH=$PATH:/usr/local/go/bin' >> ~/.bashrc
echo 'export GOPATH=$HOME/go' >> ~/.bashrc # GOPATH 설정 (선택 사항이지만 관례)
echo 'export PATH=$PATH:$GOPATH/bin' >> ~/.bashrc # GOPATH/bin도 PATH에 추가 (선택 사항)

# 변경된 .bashrc 적용 (새 터미널을 열거나 다음 명령어 실행)
source ~/.bashrc

# 설치 확인
go version

==오류 발생시5==
Vendoring Go dependencies at ../asset-transfer-basic/chaincode-go 로그 및 go: downloading ... 로그들:
go: updates to go.mod needed; to update it: go mod tidy 메시지:
Error: failed to normalize chaincode path: 'go list' failed with: go: updates to go.mod needed, disabled by -mod=vendor ... to update it: go mod tidy: exit status 1:
Error: failed to read chaincode package at 'basic.tar.gz': open basic.tar.gz: no such file or directory:

--해결 방법--

cd ../asset-transfer-basic/chaincode-go
go mod tidy
go mod vendor
cd ../../test-network  # test-network 디렉토리로 이동
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go

==스마트 컨트랙트 코드 작성 및 재배포==

1. 디렉토리 구조 만들기
fabric-samples/chaincode/contract 위치에 다음 구조를 만듭니다:

contract/
├── index.js
├── package.json

2. 스마트 컨트랙트 코드 작성 (index.js)
'use strict';

const { Contract } = require('fabric-contract-api');

class FileContract extends Contract {
  async initLedger(ctx) {
    console.info('Chaincode 초기화 완료');
  }

  async storeFileHash(ctx, fileId, fileHash) {
    await ctx.stub.putState(fileId, Buffer.from(fileHash));
    return `파일 해시 저장 완료: ${fileId}`;
  }

  async verifyFile(ctx, fileId, hashToCheck) {
    const storedHash = await ctx.stub.getState(fileId);
    if (!storedHash || storedHash.length === 0) {
      throw new Error(`파일 ${fileId} 가 존재하지 않음`);
    }

    return storedHash.toString() === hashToCheck;
  }
}

module.exports = FileContract;

3. package.json 만들기
{
  "name": "filecontract",
  "version": "1.0.0",
  "description": "파일 해시 블록체인 저장 스마트컨트랙트",
  "main": "index.js",
  "scripts": {
    "start": "fabric-chaincode-node start"
  },
  "dependencies": {
    "fabric-contract-api": "^2.2.0",
    "fabric-shim": "^2.2.0"
  }
}

4. Chaincode 테스트 및 배포
cd fabric-samples/test-network
./network.sh deployCC -ccn filecontract -ccp ../chaincode/contract -ccl javascript

5. FileUploadController 수정
package com.example.demo;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

@RestController
@RequestMapping("/api") // 기존 클래스 레벨 @RequestMapping 유지
public class FileUploadController {

// application.properties 또는 application.yml 에서 설정값 주입
	@Value("${file.upload-dir}")
	private String uploadDir; // 예: uploads/ 또는 /your/storage/path/

	@Value("${blockchain.gateway.url}")
	private String blockchainUrl; // 예: http://localhost:4000/store

	@PostMapping("/upload") // 기존 메소드 레벨 @PostMapping 유지
	public ResponseEntity<?> uploadFileAndStoreHash(@RequestParam("file") MultipartFile file) {
		if (file.isEmpty()) {
			return new ResponseEntity<>("파일을 선택하세요!", HttpStatus.BAD_REQUEST);
		}

		try {
// 1. 파일 저장
			String filename = file.getOriginalFilename();
			saveUploadedFile(file);

// 2. SHA-256 해시 생성
			byte[] fileBytes = file.getBytes();
			String encodedHash = generateSha256Hash(fileBytes);

// 3. 하이퍼레저 호출 (REST 방식으로 Node.js Gateway에 POST)
			ResponseEntity<String> blockchainResponse = callHyperledgerGateway(filename, encodedHash);

// 하이퍼레저 응답 상태에 따른 처리
			if (blockchainResponse.getStatusCode().is2xxSuccessful()) {
				return ResponseEntity.ok("파일 업로드 및 해시의 블록체인 저장 성공: " + blockchainResponse.getBody());
			} else {
// 파일은 저장되었으나, 블록체인 기록에 실패한 경우
				return ResponseEntity.status(blockchainResponse.getStatusCode())
						.body("파일 업로드는 성공했으나, 블록체인 네트워크 오류 발생: " + blockchainResponse.getBody());
			}

		} catch (IOException e) {
// 파일 저장 또는 file.getBytes() 에서 발생 가능
			return new ResponseEntity<>("파일 처리 중 오류 발생: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (NoSuchAlgorithmException e) {
			return new ResponseEntity<>("해시 생성 중 오류 발생 (알고리즘 문제): " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (RestClientException e) {
// RestTemplate으로 하이퍼레저 호출 시 발생 가능 (네트워크 연결 문제 등)
			return new ResponseEntity<>("블록체인 네트워크 통신 오류: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
		} catch (Exception e) {
// 기타 예상치 못한 예외 처리
			return new ResponseEntity<>("요청 처리 중 알 수 없는 오류 발생: " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}

	private void saveUploadedFile(MultipartFile file) throws IOException {
		File dir = new File(uploadDir);
		if (!dir.exists()) {
			boolean created = dir.mkdirs(); // 디렉토리 생성
			if (!created) {
				throw new IOException("업로드 디렉토리를 생성할 수 없습니다: " + uploadDir);
			}
		}

		Path path = Paths.get(uploadDir + file.getOriginalFilename());
		Files.write(path, file.getBytes());
	}

	private String generateSha256Hash(byte[] fileBytes) throws NoSuchAlgorithmException {
		MessageDigest digest = MessageDigest.getInstance("SHA-256");
		byte[] hash = digest.digest(fileBytes);
		return Base64.getEncoder().encodeToString(hash);
	}

	private ResponseEntity<String> callHyperledgerGateway(String fileId, String fileHash) throws RestClientException {
		Map<String, String> payload = new HashMap<>();
		payload.put("fileId", fileId);
		payload.put("fileHash", fileHash);

		RestTemplate restTemplate = new RestTemplate();
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);
		HttpEntity<Map<String, String>> request = new HttpEntity<>(payload, headers);

// blockchainUrl은 @Value로 주입받은 멤버 변수 사용
		return restTemplate.postForEntity(blockchainUrl, request, String.class);
	}
}

application.properties (또는 application.yml) 설정 예시:

# 파일 업로드 디렉토리 (애플리케이션 실행 위치 기준 상대 경로 또는 절대 경로)
file.upload-dir=uploads/

# 하이퍼레저 연동을 위한 Node.js 게이트웨이 주소
blockchain.gateway.url=http://localhost:4000/store

